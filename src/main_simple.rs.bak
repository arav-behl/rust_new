use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use chrono::Utc;
use axum::{
    extract::State,
    response::Json,
    routing::{get, post},
    Router,
};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
use futures_util::{SinkExt, StreamExt};
use tokio_tungstenite::{connect_async, tungstenite::Message};

// Binance WebSocket ticker data structure
#[derive(Debug, Deserialize)]
pub struct BinanceTicker {
    pub s: String,   // Symbol
    pub c: String,   // Current price
    pub h: String,   // High price
    pub l: String,   // Low price
    pub v: String,   // Volume
    pub q: String,   // Quote volume
}

// Binance WebSocket depth data structure
#[derive(Debug, Deserialize)]
pub struct BinanceDepth {
    pub s: String,                    // Symbol
    pub b: Vec<(String, String)>,     // Bids [price, quantity]
    pub a: Vec<(String, String)>,     // Asks [price, quantity]
}

// Simple types for the working version
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimpleOrder {
    pub id: u64,
    pub symbol: String,
    pub side: String, // "buy" or "sell"
    pub quantity: f64,
    pub price: Option<f64>,
    pub status: String,
    pub timestamp: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimplePosition {
    pub symbol: String,
    pub quantity: f64,
    pub average_price: f64,
    pub market_value: f64,
    pub pnl: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketDepth {
    pub symbol: String,
    pub bid_price: f64,
    pub ask_price: f64,
    pub bid_quantity: f64,
    pub ask_quantity: f64,
    pub spread: f64,
    pub mid_price: f64,
    pub last_update: chrono::DateTime<chrono::Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimplePortfolio {
    pub cash_balance: f64,
    pub total_value: f64,
    pub positions: HashMap<String, SimplePosition>,
    pub total_pnl: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimpleOrderRequest {
    pub symbol: String,
    pub side: String,
    pub quantity: f64,
    pub price: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ApiResponse<T> {
    pub success: bool,
    pub data: Option<T>,
    pub error: Option<String>,
}

// Simple trading engine state
#[derive(Clone)]
pub struct SimpleTradingEngine {
    orders: Arc<RwLock<Vec<SimpleOrder>>>,
    portfolio: Arc<RwLock<SimplePortfolio>>,
    current_prices: Arc<RwLock<HashMap<String, f64>>>,
    market_depth: Arc<RwLock<HashMap<String, MarketDepth>>>,
    order_counter: Arc<std::sync::atomic::AtomicU64>,
}

impl SimpleTradingEngine {
    pub fn new() -> Self {
        // Initialize with empty prices - will be populated by live feed
        let current_prices = HashMap::new();
        let market_depth = HashMap::new();

        let portfolio = SimplePortfolio {
            cash_balance: 100000.0, // Start with $100k
            total_value: 100000.0,
            positions: HashMap::new(),
            total_pnl: 0.0,
        };

        Self {
            orders: Arc::new(RwLock::new(Vec::new())),
            portfolio: Arc::new(RwLock::new(portfolio)),
            current_prices: Arc::new(RwLock::new(current_prices)),
            market_depth: Arc::new(RwLock::new(market_depth)),
            order_counter: Arc::new(std::sync::atomic::AtomicU64::new(1)),
        }
    }

    // Start live price feeds from Binance
    pub async fn start_price_feeds(&self) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
        // Focus on three main trading pairs for the demo
        let symbols = ["btcusdt", "ethusdt", "solusdt"];

        // Start ticker feed for price updates
        let ticker_stream_names: Vec<String> = symbols.iter()
            .map(|s| format!("{}@ticker", s))
            .collect();

        let ticker_url = format!(
            "wss://stream.binance.com:9443/ws/{}",
            ticker_stream_names.join("/")
        );

        // Start order book depth feeds for bid/ask data
        let depth_stream_names: Vec<String> = symbols.iter()
            .map(|s| format!("{}@depth5@100ms", s))
            .collect();

        let depth_url = format!(
            "wss://stream.binance.com:9443/ws/{}",
            depth_stream_names.join("/")
        );

        let prices = Arc::clone(&self.current_prices);
        let depth = Arc::clone(&self.market_depth);

        // Start ticker feed task
        let ticker_prices = Arc::clone(&prices);
        tokio::spawn(async move {
            loop {
                match connect_async(&ticker_url).await {
                    Ok((ws_stream, _)) => {
                        println!("üîó Connected to Binance WebSocket for live prices");
                        let (mut _write, mut read) = ws_stream.split();

                        while let Some(msg) = read.next().await {
                            match msg {
                                Ok(Message::Text(text)) => {
                                    if let Ok(ticker) = serde_json::from_str::<BinanceTicker>(&text) {
                                        let symbol = ticker.s.to_uppercase();
                                        let price: f64 = ticker.c.parse().unwrap_or(0.0);

                                        {
                                            let mut prices_lock = ticker_prices.write().await;
                                            prices_lock.insert(symbol.clone(), price);
                                        }

                                        println!("üìà Live Price Update: {} = ${:.2}", symbol, price);
                                    }
                                }
                                Ok(Message::Close(_)) => {
                                    println!("‚ö†Ô∏è WebSocket connection closed");
                                    break;
                                }
                                Err(e) => {
                                    println!("‚ùå WebSocket error: {}", e);
                                    break;
                                }
                                _ => {}
                            }
                        }
                    }
                    Err(e) => {
                        println!("‚ùå Failed to connect to Binance: {}", e);
                        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                    }
                }

                println!("üîÑ Reconnecting to price feed in 5 seconds...");
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            }
        });

        // Start order book depth feed task
        tokio::spawn(async move {
            loop {
                match connect_async(&depth_url).await {
                    Ok((ws_stream, _)) => {
                        println!("üìä Connected to Binance WebSocket for order book depth");
                        let (mut _write, mut read) = ws_stream.split();

                        while let Some(msg) = read.next().await {
                            match msg {
                                Ok(Message::Text(text)) => {
                                    if let Ok(depth_data) = serde_json::from_str::<BinanceDepth>(&text) {
                                        let symbol = depth_data.s.to_uppercase();

                                        // Parse best bid and ask
                                        if let (Some(best_bid), Some(best_ask)) = (
                                            depth_data.b.first(),
                                            depth_data.a.first()
                                        ) {
                                            let bid_price = best_bid.0.parse::<f64>().unwrap_or(0.0);
                                            let ask_price = best_ask.0.parse::<f64>().unwrap_or(0.0);
                                            let bid_quantity = best_bid.1.parse::<f64>().unwrap_or(0.0);
                                            let ask_quantity = best_ask.1.parse::<f64>().unwrap_or(0.0);

                                            let spread = ask_price - bid_price;
                                            let mid_price = (bid_price + ask_price) / 2.0;

                                            let market_depth = MarketDepth {
                                                symbol: symbol.clone(),
                                                bid_price,
                                                ask_price,
                                                bid_quantity,
                                                ask_quantity,
                                                spread,
                                                mid_price,
                                                last_update: chrono::Utc::now(),
                                            };

                                            {
                                                let mut depth_lock = depth.write().await;
                                                depth_lock.insert(symbol.clone(), market_depth);
                                            }

                                            println!("üìñ Order Book Update: {} - Bid: ${:.2} Ask: ${:.2} Spread: ${:.2}",
                                                symbol, bid_price, ask_price, spread);
                                        }
                                    }
                                }
                                Ok(Message::Close(_)) => {
                                    println!("‚ö†Ô∏è Order book WebSocket connection closed");
                                    break;
                                }
                                Err(e) => {
                                    println!("‚ùå Order book WebSocket error: {}", e);
                                    break;
                                }
                                _ => {}
                            }
                        }
                    }
                    Err(e) => {
                        println!("‚ùå Failed to connect to Binance order book feed: {}", e);
                        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
                    }
                }

                println!("üîÑ Reconnecting to order book feed in 5 seconds...");
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            }
        });

        Ok(())
    }

    pub async fn submit_order(&self, request: SimpleOrderRequest) -> Result<SimpleOrder, String> {
        // Get market depth for realistic pricing
        let (fill_price, execution_notes) = {
            let depth = self.market_depth.read().await;
            match depth.get(&request.symbol) {
                Some(market_data) => {
                    // Use realistic bid/ask spread for execution
                    let is_buy = request.side.to_lowercase() == "buy";
                    let realistic_price = if is_buy {
                        // Buying: pay the ask price (or higher if limit order)
                        if let Some(limit_price) = request.price {
                            if limit_price >= market_data.ask_price {
                                market_data.ask_price // Market order or aggressive limit
                            } else {
                                return Err(format!("Buy limit order at ${:.2} below ask price ${:.2}",
                                          limit_price, market_data.ask_price));
                            }
                        } else {
                            market_data.ask_price // Market order
                        }
                    } else {
                        // Selling: receive the bid price (or lower if limit order)
                        if let Some(limit_price) = request.price {
                            if limit_price <= market_data.bid_price {
                                market_data.bid_price // Market order or aggressive limit
                            } else {
                                return Err(format!("Sell limit order at ${:.2} above bid price ${:.2}",
                                          limit_price, market_data.bid_price));
                            }
                        } else {
                            market_data.bid_price // Market order
                        }
                    };

                    let notes = format!("Executed at realistic {} price (spread: ${:.2})",
                                       if is_buy { "ask" } else { "bid" },
                                       market_data.spread);
                    (realistic_price, notes)
                }
                None => {
                    // Fallback to ticker price if order book not available
                    let prices = self.current_prices.read().await;
                    let price = *prices.get(&request.symbol).ok_or("Symbol not found")?;
                    let fallback_price = request.price.unwrap_or(price);
                    (fallback_price, "Executed at ticker price (order book unavailable)".to_string())
                }
            }
        };

        // Create order
        let order_id = self.order_counter.fetch_add(1, std::sync::atomic::Ordering::SeqCst);

        let mut order = SimpleOrder {
            id: order_id,
            symbol: request.symbol.clone(),
            side: request.side.clone(),
            quantity: request.quantity,
            price: Some(fill_price),
            status: "filled".to_string(), // Realistic execution with bid/ask spread
            timestamp: Utc::now(),
        };

        println!("‚ö° Order Executed: {} {} {} @ ${:.2} - {}",
                order_id, request.side.to_uppercase(), request.symbol,
                fill_price, execution_notes);

        // Update portfolio
        {
            let mut portfolio = self.portfolio.write().await;
            self.update_portfolio(&mut portfolio, &order).await;
        }

        // Store order
        {
            let mut orders = self.orders.write().await;
            orders.push(order.clone());
        }

        Ok(order)
    }

    async fn update_portfolio(&self, portfolio: &mut SimplePortfolio, order: &SimpleOrder) {
        let trade_value = order.quantity * order.price.unwrap_or(0.0);
        let is_buy = order.side.to_lowercase() == "buy";

        // Update cash
        if is_buy {
            portfolio.cash_balance -= trade_value;
        } else {
            portfolio.cash_balance += trade_value;
        }

        // Update position
        let position = portfolio.positions.entry(order.symbol.clone())
            .or_insert(SimplePosition {
                symbol: order.symbol.clone(),
                quantity: 0.0,
                average_price: 0.0,
                market_value: 0.0,
                pnl: 0.0,
            });

        if is_buy {
            // Calculate new average price
            let total_cost = position.quantity * position.average_price + trade_value;
            position.quantity += order.quantity;
            if position.quantity > 0.0 {
                position.average_price = total_cost / position.quantity;
            }
        } else {
            position.quantity -= order.quantity;
            if position.quantity.abs() < 0.0001 {
                position.quantity = 0.0;
                position.average_price = 0.0;
            }
        }

        // Update market value and PnL using live prices
        if let Some(current_price) = self.current_prices.read().await.get(&order.symbol) {
            position.market_value = position.quantity * current_price;
            position.pnl = (current_price - position.average_price) * position.quantity;
        } else {
            // If live price not available yet, use order price as fallback
            let fallback_price = order.price.unwrap_or(0.0);
            position.market_value = position.quantity * fallback_price;
            position.pnl = (fallback_price - position.average_price) * position.quantity;
        }

        // Calculate total portfolio value
        let mut total_value = portfolio.cash_balance;
        let mut total_pnl = 0.0;

        for pos in portfolio.positions.values() {
            total_value += pos.market_value;
            total_pnl += pos.pnl;
        }

        portfolio.total_value = total_value;
        portfolio.total_pnl = total_pnl;
    }

    pub async fn get_portfolio(&self) -> SimplePortfolio {
        self.portfolio.read().await.clone()
    }

    pub async fn get_orders(&self) -> Vec<SimpleOrder> {
        self.orders.read().await.clone()
    }

    // Refresh all position values with current live prices
    pub async fn refresh_portfolio_with_live_prices(&self) {
        let mut portfolio = self.portfolio.write().await;
        let prices = self.current_prices.read().await;

        let mut total_value = portfolio.cash_balance;
        let mut total_pnl = 0.0;

        for (symbol, position) in portfolio.positions.iter_mut() {
            if let Some(&current_price) = prices.get(symbol) {
                position.market_value = position.quantity * current_price;
                position.pnl = (current_price - position.average_price) * position.quantity;
                total_value += position.market_value;
                total_pnl += position.pnl;
            }
        }

        portfolio.total_value = total_value;
        portfolio.total_pnl = total_pnl;
    }

    pub async fn get_market_depth(&self) -> HashMap<String, MarketDepth> {
        self.market_depth.read().await.clone()
    }
}

// API Handlers
async fn submit_order(
    State(engine): State<SimpleTradingEngine>,
    Json(request): Json<SimpleOrderRequest>,
) -> Json<ApiResponse<SimpleOrder>> {
    match engine.submit_order(request).await {
        Ok(order) => Json(ApiResponse {
            success: true,
            data: Some(order),
            error: None,
        }),
        Err(e) => Json(ApiResponse {
            success: false,
            data: None,
            error: Some(e),
        }),
    }
}

async fn get_portfolio(
    State(engine): State<SimpleTradingEngine>,
) -> Json<ApiResponse<SimplePortfolio>> {
    // Refresh portfolio with latest live prices
    engine.refresh_portfolio_with_live_prices().await;
    let portfolio = engine.get_portfolio().await;
    Json(ApiResponse {
        success: true,
        data: Some(portfolio),
        error: None,
    })
}

async fn get_orders(
    State(engine): State<SimpleTradingEngine>,
) -> Json<ApiResponse<Vec<SimpleOrder>>> {
    let orders = engine.get_orders().await;
    Json(ApiResponse {
        success: true,
        data: Some(orders),
        error: None,
    })
}

#[derive(Deserialize)]
struct HealthQuery {}

async fn health_check() -> Json<ApiResponse<String>> {
    Json(ApiResponse {
        success: true,
        data: Some("Live Trading Engine - Connected to Binance WebSocket".to_string()),
        error: None,
    })
}

async fn get_live_prices(
    State(engine): State<SimpleTradingEngine>,
) -> Json<ApiResponse<HashMap<String, f64>>> {
    let prices = engine.current_prices.read().await;
    Json(ApiResponse {
        success: true,
        data: Some(prices.clone()),
        error: None,
    })
}

async fn get_market_depth(
    State(engine): State<SimpleTradingEngine>,
) -> Json<ApiResponse<HashMap<String, MarketDepth>>> {
    let depth = engine.get_market_depth().await;
    Json(ApiResponse {
        success: true,
        data: Some(depth),
        error: None,
    })
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Initialize tracing
    tracing_subscriber::fmt::init();

    println!("üöÄ Starting Live Trading Engine with Real Market Data");
    println!("=====================================================");

    // Create trading engine
    let engine = SimpleTradingEngine::new();

    // Start live price feeds from Binance
    println!("üîó Connecting to Binance WebSocket for live market data...");
    engine.start_price_feeds().await?;

    // Wait a moment for initial price data
    tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;

    // Create router
    let app = Router::new()
        .route("/health", get(health_check))
        .route("/api/v1/orders", post(submit_order))
        .route("/api/v1/orders", get(get_orders))
        .route("/api/v1/portfolio", get(get_portfolio))
        .route("/api/v1/prices", get(get_live_prices))
        .route("/api/v1/depth", get(get_market_depth))
        .with_state(engine);

    let addr: SocketAddr = "0.0.0.0:8080".parse()?;
    println!("üåê REST API server starting on http://{}", addr);
    println!();
    println!("üìã Available Endpoints:");
    println!("   GET  /health                - Health check & connection status");
    println!("   GET  /api/v1/prices         - Live market prices (BTC, ETH, SOL)");
    println!("   GET  /api/v1/depth          - Real-time order book depth with bid/ask spreads");
    println!("   POST /api/v1/orders         - Submit order (realistic bid/ask execution)");
    println!("   GET  /api/v1/orders         - Get order history with execution details");
    println!("   GET  /api/v1/portfolio      - Get portfolio with live P&L");
    println!();

    // Display system capabilities
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
        println!("‚úÖ Live Trading System Operational!");
        println!("   üìä Real-time price data from Binance WebSocket");
        println!("   ‚ö° Orders executed at current market prices");
        println!("   üí∞ Dynamic P&L calculations with live prices");
        println!("   üîÑ Automatic reconnection on connection loss");
        println!("   üìà Professional market data integration");
        println!();
        println!("üéØ Perfect for demonstrating quantitative trading expertise!");
        println!("   ‚Ä¢ Market microstructure understanding");
        println!("   ‚Ä¢ Real-time data processing");
        println!("   ‚Ä¢ Risk management with live positions");
        println!("   ‚Ä¢ Production-grade WebSocket handling");
    });

    let listener = tokio::net::TcpListener::bind(addr).await?;
    axum::serve(listener, app).await?;

    Ok(())
}